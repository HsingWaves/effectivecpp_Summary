### Commonality and variability ananlysis
1.To avoid code bloat, classes generated by templates should not have dependencies
relationship with the bloat template parameter.

2.Non-type template can be avoid, using function parameter or class member variables
to replace template parameter.

3.Code bloat from type parameters can be lowed down through instantiation types which
have binary representations share implementation

Example:
```
template<typename T, std::size_t n>
class SquareMatrix{
public:
	...
	void invert(); // find []-1
};

SquareMatrix<double,5>sm1;
..
sml.invert();
SquareMatrix<double,10>sm2;
...
sm2.invert();
//except 5 and 10, other parts are the same
//modification
template<typename T>
class SquareMatrixBase{
protected:
	...
	void invert(std::size_t matrixSize); // find []-1
};

template<typename T, std::size_t n>
class SquareMatrix:private SquareMatrixBase<T>{
private:
	using SquareMatrixBase<T>::invert;
public:
	...
	void invert(){this->invert(n);} // find []-1
};
//but above code,SquareMatrixBase::invert does't know which data it can operate
template<typename T, std::size_t n>
class SquareMatrix:private SquareMatrixBase<T>{
private:
	using SquareMatrixBase<T>::invert;
public:
	...
	SquareMatrix():SquareMatrixBase<T>(n,0),
	pData(new T[n*n])
	{this->setDataPtr(pData.get());}
	...
private:
	boost::scoped_array<T> pData;
};
	
//put the data into head, boost::scoped_array see tip 13
```